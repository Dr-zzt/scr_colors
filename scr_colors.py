# scr_colors v4.0.0 
# Made by Ninfia, modified by Defender
# Some code is from Armoha's MSQC
import re
import struct
from typing import TYPE_CHECKING
from eudplib import *
Address_RECOVER		= 0x58F450
Address_VALUE		= 1
Address_WAIT		= 0xDB8714
Address_WAIT_FLAG	= 0xDB870C
if TYPE_CHECKING:
	settings: dict[str, str] = {}

Size = { # a<=X<b, Valid Range
	"uc" : [[0,12]],
	"mc" : [[0,12]],
	"scc" : [[0,12]],
	"wfp" : [[0,24],[104,116],[156,196]],
	"wfc" : [[0,136]],
	"scp" : [[0,3],[5,7]],
	"tp" : [[0,24]],
	"mp" : [[0,32]],
	"256p" : [[0,256]],
	"df" : [[0,4]],
	"sf" : [[0,4]],
	"scf" : [[0,4]]
}
Addr = {
	"uc" : 0x581D76, # Unit Color / EUD Addr
	"mc" : 0x581DD6, # Minimap Color / EUD Addr
	"scc" : 0x581D6A, # Selection Circle Color / EUD Addr
	"wfp" : 0xDB20B8, # Wireframe Palette
	"wfc" : 0xB308A8, # Wireframe Color
	"scp" : 0xB95F43, # Selection Circle Palette
	"tp" : 0xDCB608, # Text Palette
	"mp" : 0xDCB730, # Misc Palette
	"256p" : 0xBA9068, # 256 Color Palette
	"df" : 0xB3CA58, # Dragbox Color Filter
	"sf" : 0xB3CA68, # Shadow Color Filter
	"scf" : 0xB3CA88 # Screen Color Filter
}
D: dict[str, dict[int, int|tuple[str, int]|tuple[str, int, int, int]]] = { # SetEWait Act for Write Values
	"wfp" : {}, 
	"wfc" : {},
	"scp" : {},
	"tp" : {},
	"mp" : {},
	"256p" : {},
	"df" : {},
	"sf" : {},
	"scf" : {}
}
N = len(D.keys())
Raw = { # Original Data
	"wfp" : [0x87,0x75,0x8A,0xA5,0xA5,0xA2,0xA2,0xA0,0xA0,0x29,0xAE,0x17,0x17,0x62,0xA4,0xA4,0xA3,0xA1,0x9C,0xB1,0x1A,0x00,0x00,0x00],
	"wfc" : [0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x00,0x0A,0x0A,0x00,0x00,0x0A,0x0A,0x00,0x01,0x0A,0x0A,0x01,0x01,0x0A,0x00,0x01,0x01,0x0A,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x00,0x0A,0x0A,0x00,0x00,0x0A,0x00,0x00,0x00,0x0A,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x01,0x00,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x09,0x02,0x08,0x09,0x07,0x08,0x06,0x07,0x05,0x06,0x04,0x05,0x03,0x04,0x0E,0x06,0x07,0x08,0x13,0x0B,0x0D,0x06,0x13,0x0B,0x0A,0x10,0x01,0x12,0x14,0x10,0x01,0x12,0x14,0x0C,0x00,0x01,0x12,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
	"scp" : [0xB8,0xB9,0xB9,0xBA,0xB9,0xBA,0x75,0xBD,0x6A,0x81,0x6D,0xA6,0x6D,0xA7,0x3D,0x3D,0x62,0x62,0x62,0x62,0x64,0xAD,0x17,0x6F,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x08,0x00,0xA9,0xFE,0x88,0x13,0x00,0x00,0x10,0x27,0x00,0x00,0x70,0xFF,0x1D,0x13,0x01,0x00,0x00,0x00],
	"tp" : [0xC0,0x9B,0x9A,0x95,0x43,0x00,0x00,0x28,0x56,0xA7,0x6D,0x65,0x5C,0x00,0x00,0x8A,0x41,0xFF,0x53,0x97,0x47,0x00,0x00,0x8A,0x40,0x96,0x49,0x90,0x42,0x00,0x00,0x8A,0xA8,0xAE,0x17,0x5E,0xAA,0x00,0x00,0x8A,0xB5,0x75,0xBA,0xB9,0xB7,0x00,0x00,0x8A,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x8A,0x6F,0x17,0x5E,0xAA,0x8A,0x8A,0x8A,0x28,0xA5,0xA2,0x2D,0xA0,0x8A,0x8A,0x8A,0x8A,0x9F,0x9E,0x9D,0xB7,0x8A,0x8A,0x8A,0x8A,0xA4,0xA3,0xA1,0x0E,0x8A,0x8A,0x8A,0x8A,0x9C,0x1C,0x1A,0x13,0x8A,0x8A,0x8A,0x8A,0x13,0x12,0x11,0x57,0x8A,0x8A,0x8A,0x8A,0x54,0x51,0x4E,0x4A,0x8A,0x8A,0x8A,0x8A,0x87,0xA6,0x81,0x93,0x8A,0x8A,0x8A,0xB5,0xB9,0xB8,0xB7,0xB6,0x8A,0x8A,0x8A,0x8A,0x88,0x84,0x81,0x60,0x8A,0x8A,0x8A,0x8A,0x86,0x72,0x70,0x69,0x8A,0x8A,0x8A,0x8A,0x33,0x7C,0x7A,0xA0,0x8A,0x8A,0x8A,0x8A,0x4D,0x26,0x23,0x22,0x8A,0x8A,0x8A,0x8A,0x9A,0x97,0x95,0x91,0x8A,0x8A,0x8A,0x8A,0x88,0x84,0x81,0x60,0x8A,0x8A,0x8A,0x8A,0x80,0x34,0x31,0x2E,0x8A,0x8A,0x8A],
	"mp" : [0xFF,0x54,0x54,0x53,0x51,0x99,0x4E,0x96,0x4A,0x49,0x47,0x90,0xEF,0x42,0x8B,0xCF,0xA5,0x87,0x75,0xB9,0xAE,0x9C,0x7C,0x14,0x99,0x80,0x00,0x00,0x00,0x00,0x00,0x00],
	"256p" : [0x00000000,0x003B2727,0x00472F2F,0x00533B37,0x004B332F,0x00432B2B,0x003B2727,0x00775753,0x006F4F4B,0x00674B47,0x0073534F,0x00835F57,0x00936B63,0x00A3776B,0x003A003A,0x00190019,0x0018242C,0x00142448,0x00142C5C,0x00143070,0x00243C68,0x0018407C,0x002C4C78,0x000808A8,0x0030548C,0x00446084,0x001C54A0,0x00184CC4,0x002468BC,0x003C70B4,0x002064D0,0x003494DC,0x005494E0,0x0054C4EC,0x00284434,0x003C6C40,0x00506C48,0x0050804C,0x005C8C50,0x0078A05C,0x00180000,0x00341000,0x00500800,0x00483424,0x00544030,0x007C3414,0x006C4C34,0x00745840,0x008C6848,0x009C7000,0x00A48058,0x00D46840,0x00B8AC18,0x00FC2424,0x00BC9464,0x00CCA870,0x00D8C08C,0x00F4DC94,0x00E8DCAC,0x00FCFCAC,0x00F8F8CC,0x0000FCFC,0x0090E4F4,0x00C0FCFC,0x000C0C0C,0x00101418,0x00201C1C,0x00302828,0x00243038,0x00443C38,0x0030404C,0x004C4C4C,0x0040505C,0x00585858,0x00686868,0x006C8478,0x006C9468,0x007CA474,0x008C9498,0x0094B890,0x00A8C498,0x00B0B0B0,0x00B0CCAC,0x00BCC0C4,0x00D0E0CC,0x00F0F0F0,0x0008101C,0x000C1828,0x00081034,0x000C2034,0x00201038,0x00202834,0x00083444,0x00183048,0x00000060,0x00202854,0x00144050,0x0014545C,0x00040484,0x00344C68,0x0030387C,0x00206470,0x0050507C,0x001C34A4,0x00006C94,0x00405C98,0x0034808C,0x00547498,0x004454B8,0x001890B0,0x005C74B0,0x000404F4,0x005478C8,0x005468FC,0x0084A4E0,0x006894FC,0x002CCCFC,0x0018FC10,0x0020000C,0x002C1C1C,0x004C2424,0x00682C28,0x0084302C,0x00B81820,0x00AC3C34,0x00946868,0x00FC9064,0x00FCAC7C,0x00FCE400,0x0040909C,0x005494A8,0x005CA4BC,0x0060B8CC,0x0080D8E8,0x00B0C4EC,0x0038FCFC,0x007CFCFC,0x00A4FCFC,0x00080808,0x00101010,0x00181818,0x00282828,0x00343434,0x00383C4C,0x00444444,0x00584848,0x00685858,0x00386874,0x005C6478,0x007C6060,0x00747484,0x009C8484,0x007C8CAC,0x009498AC,0x00B89090,0x00E8B8B8,0x00148CF8,0x003C5410,0x00709020,0x0094B42C,0x00642004,0x00501C48,0x00983408,0x00783068,0x009C4088,0x00CC480C,0x0034B8BC,0x003CDCDC,0x00000010,0x00000024,0x00000034,0x00000048,0x00041860,0x0008288C,0x001818C8,0x002C2CE0,0x002020E8,0x001450E8,0x002020FC,0x002478E8,0x003CACF8,0x00001400,0x00002800,0x00004400,0x00006400,0x00088008,0x00249824,0x003C9C3C,0x0058B058,0x0068B868,0x0080C480,0x0094D494,0x0024140C,0x00643C24,0x00845030,0x00945C38,0x00B47448,0x00C48454,0x00D49460,0x00ECB478,0x00081014,0x000C1418,0x000C2C24,0x00181010,0x00201414,0x00402C2C,0x00684C44,0x00040404,0x0010181C,0x00141C20,0x001C2024,0x001C2830,0x002C3840,0x00384854,0x004C5C68,0x00647C90,0x00142028,0x00142830,0x00182C34,0x001C2C38,0x001C303C,0x00243844,0x00304454,0x0004100C,0x00041814,0x00081C18,0x0008201C,0x000C2420,0x0010342C,0x00103C34,0x00104840,0x00302020,0x003C2828,0x00483430,0x00141414,0x001C1820,0x00182028,0x00241C24,0x00242428,0x002C2C30,0x00342C3C,0x003C383C,0x00303C48,0x00403444,0x00483C50,0x0034505C,0x00FF2323,0x00FF2323,0x002B3B47,0x002F3F4B,0x00334353,0x00674B43,0x006F534B,0x007B5B53,0x0087635B,0x00FFFFFF],
	"df" : [0x3D808081,0x3F7CFCFD,0x3DC0C0C1,0x3F800000],
	"sf" : [0x00000000,0x00000000,0x00000000,0x3F800000],
	"scf" : [0x3F800000,0x3F800000,0x3F800000,0x3F800000]
}
# 2nd = ((1st - Address_WAIT)//4 + Address_WAIT_FLAG)
Rewrite = { # Reset Wait flags before SetEWait (Left→Right Order Exec)
	"tp" : [[0xDB8754,0xDB8838,0xDB8BC4,0xDB99F8,0xDBD2C8],[1,1,2,4,13],False],
	"mp" : [[0xDB8754,0xDB8838,0xDB8BC8,0xDB9A08,0xDBD310],[1,1,1,2,3],False]
}
Recover = { # Reset Wait flags after SetEWait (Left→Right Order Exec)
	"wfc" : [[0xD8FF20,0xD16770],[10,35]],
	"scp" : [[0xD9648C,0xD2FD14],[1,4]],
	"df" : [[0xD90B3C,0xD197DC],[1,2]],
	"sf" : [[0xD90B3C,0xD197E0],[2,2]],
	"scf" : [[0xD90B40,0xD197E8],[1,2]]
}
R: dict[str, dict[int, int]] = { # SetEWait Act for Recover Values
	"wfc" : {},
	"scp" : {},
	"df" : {},
	"sf" : {},
	"scf" : {}
}
Cond = { # Patch Condition
	"uc" : [0,0],
	"mc" : [0,0],
	"scc" : [0,0],
	"wfp" : [0,0],
	"wfc" : [0,0],
	"scp" : [0,0],
	"tp" : [0,0],
	"mp" : [0,0],
	"256p" : [0,0],
	"df" : [0,0],
	"sf" : [0,0],
	"scf" : [0,0]
}

cond_label_pairs: list[tuple[list, list[str]]] = []
recover_condition = None

print("[SC:R Colors v4.0.0] (Modified from v3.0, 25/06/07)")

def check_in_range(off, key):
	for loc in Size[key]:
		if loc[0] <= off < loc[1]:
			return True
	return False

def float_to_hex(f):
	return hex(struct.unpack('<I', struct.pack('<f', f))[0])

def to_num(s):
	try:
		return int(s)
	except ValueError:
		return int(s, 16)

def to_float(s):
	try:
		return float_to_hex(to_num(s) / 255)
	except ValueError:
		return float_to_hex(float(s))

def get_variable_value(var_name: str):
	ns = GetEUDNamespace()
	assert var_name in ns, f"Variable '{var_name}' not found in the current namespace."
	return ns[var_name]

def getRaw(key: str, epd: int) -> int:
	return (Raw[key][epd*4+3]<<24)+(Raw[key][epd*4+2]<<16)+(Raw[key][epd*4+1]<<8)+Raw[key][epd*4]

def interpret_condition(cond):
	if isinstance(cond, Condition):
		return cond
	# involves variables
	cond: str
	_ns = GetEUDNamespace()
	for k, v in _ns.items():
		if k in cond:
			cond = re.sub(r"\b{}\b".format(k), r"_ns['\g<0>']", cond)
			# replace variable_name with _ns[variable_name]
	return eval(cond)


mode = 1
EAct = {
	"uc" : [],
	"mc" : [],
	"scc" : []
}
VAct = {
	"uc" : [],
	"mc" : [],
	"scc" : []
}
EActused = 0
lshmask = [0xFFFFFF00,0xFFFF00FF,0xFF00FFFF,0x00FFFFFF]
bitmask = [0x000000FF,0x0000FF00,0x00FF0000,0xFF000000]

# parsing format
# (0) mode: 0 or 1
# (1) condition1; condition2; ... : label1, label2, 
# (2) label: offset, value; offset, value; ...

# condition format:
# (1) always
# (2) offset, modifier, value
# (3) offset, value - same as (2) with modifier = Exactly
# (4) involves variables. e.g. varname.AtLeast(1)

sectors = {"unit color":"uc","minimap color":"mc","selection circle color":"scc","wireframe palette":"wfp","wireframe color":"wfc","selection circle palette":"scp","text palette":"tp","misc palette":"mp","256 color palette":"256p","dragbox color filter":"df","shadow color filter":"sf","screen color filter":"scf"}
unmatched_sectors = set(sectors.keys())
for key, value in settings.items():
	original_key = key
	key = key.lower().strip()	
	con_final, act_final = [], []
	match key:
		case 'mode':
			mode = int(value)
			continue

		case "unit color" | "minimap color" | "selection circle color":
			# Editable with classic EUDs. Todo later.
			raise NotImplementedError("Unit color, minimap color, and selection circle color are not implemented yet.")
		
		case "wireframe palette" | "wireframe color" | "selection circle palette" | "text palette" | "256 color palette" | "misc palette":
			shkey = sectors[key]
			recover_needed = shkey in Recover
			ovs = value.split(";")
			for ov in ovs:
				offset, val = ov.split(",")					

				if shkey == "tp":
					offset = to_num(offset)
					colorcode = {0x02:0x01,0x03:0x09,0x04:0x11,0x05:0x19,0x06:0x21,0x07:0x29,0x08:0x41,0x0E:0x49,0x0F:0x51,0x10:0x59,0x11:0x61,0x15:0x69,0x16:0x71,0x17:0x79,0x18:0x81,0x19:0x89,0x1B:0x91,0x1C:0x99,0x1D:0xA1,0x1E:0xA9,0x1F:0xB9}
					assert offset in colorcode, f"Invalid color code {offset} for {key}."
					offset = colorcode[offset]
				elif shkey == "mp":
					misccode = {"p0":0x0,"p1":0x1,"p2":0x2,"p3":0x3,"p4":0x4,"p5":0x5,"p6":0x6,"p7":0x7,"p8":0x8,"p9":0x9,"p10":0xA,"p11":0xB,"p12":0xC,"p13":0xD,"p14":0xE,"p15":0xF,"fill":0xF,"line":0x10,"self":0x12,"res":0x19}
					offset = offset.lower().strip()
					assert offset in misccode, f"Invalid misc code {offset} for {key}."
					offset = misccode[offset]
				else:
					offset = to_num(offset)
					assert check_in_range(offset, shkey), f"Offset {offset} is out of range for {key}."

				if key == "selection circle palette":
					epd, lsh = 8 * offset // 4, 3
				else:
					epd, lsh = divmod(offset, 4)

				if shkey in Rewrite:
					Rewrite[shkey][2] = True
				
				try: # if value is a number...
					if shkey == "256p":
						D[shkey][epd] = to_num(val)
					elif epd not in D[shkey]:
						D[shkey][epd] = (to_num(val) << (lsh*8)) + ((0 if epd >= 6 and shkey == "wfp" else getRaw(shkey,epd)) & lshmask[lsh])
						if recover_needed:
							R[shkey][epd] = getRaw(shkey, epd)
					elif not isinstance(D[shkey][epd], tuple):
						D[shkey][epd] = (to_num(val) << (lsh*8)) + (D[shkey][epd] & lshmask[lsh])
					else:
						raise ValueError(f"Constant value offset {offset}, {key} collides with variable value.")
				except ValueError: # value is a variable name
					# check if value is a valid variable name
					assert re.fullmatch(r"[a-zA-Z_][a-zA-Z0-9_]*", val), f"Invalid variable name: {val}"
					assert epd not in D[shkey], f"Offset {offset} already exists in {key} for variable value."
					if shkey == "scp":
						D[shkey][epd] = (val, 1, 0x01000000, (getRaw(key,epd) & lshmask[lsh]))
					else:
						D[shkey][epd] = (val, 4)
					if recover_needed:
						R[shkey][epd] = getRaw(shkey, epd)

		case "dragbox color filter" | "shadow color filter" | "screen color filter":
			shkey = sectors[key]
			recover_needed = key in Recover # will be true
			filtercode = {"r":0x0,"g":0x4,"b":0x8,"a":0xC}

			ovs = value.split(";")
			for ov in ovs:
				offset, value = ov.split(",")
				offset = offset.lower().strip()
				assert offset in filtercode, f"Invalid filter code {offset} for {key}."
				epd = filtercode[offset] // 4
				R[shkey][epd] = Raw[shkey][epd]
				try: # if value is a number...
					D[shkey][epd] = int(to_float(val), 16)
				except ValueError: 
					D[shkey][epd] = [val, 4]
				

		case _: # condition to label correspondence
			conds = [c.strip() for c in original_key.split(";")]
			for cond in conds:
				if cond.lower() == 'always':
					pass
				else:
					c = [con.strip() for con in cond.split(",")]
					if re.fullmatch(r"0[xX][0-9a-fA-F]+", c[0]): # address of 0x##### form
						try:
							ptr, mod, val = int(c[0], 0), eval(c[1]), int(c[2], 0)
						except (IndexError, SyntaxError):
							ptr, val = int(c[0], 0), int(c[1], 0)
							con_final.append(MemoryX(ptr, Exactly, val, val))
						else:
							con_final.append(Memory(ptr, mod, val))
					else:
						con_final.append(cond)
				
			# parse labels
			for v in value.split(","):
				v = v.strip().lower()
				if v == "recover":
					act_final.append('recover')
				elif v in sectors:
					act_final.append(v)
					unmatched_sectors.remove(v)
				else:
					raise ValueError(f"Invalid label {v} in {key}.")
				
			if 'recover' in act_final:
				assert len(act_final) == 1, "Recover can't go together with another label."
			cond_label_pairs.append((con_final, act_final))

# put unmatched sectors into cond_act_pairs with empty conditions
cond_label_pairs.append(([], [v for v in unmatched_sectors if sectors[v] in D]))


@EUDFunc
def SetEWait(src, val):
	ftrg = Forward()
	VProc(
		v=[src, val],
		actions=[
			SetMemory(ftrg+0x164+0x20, SetTo, 4),
			SetMemory(ftrg+0x948, SetTo, 4), # internal flag
			SetMemoryX(ftrg+0x964, SetTo, 0x0, 0xFF000000),
			src.QueueAssignTo(EPD(ftrg)+(8+320+20)//4),
			val.QueueAssignTo(EPD(ftrg)+(8+320+32+12)//4)
		]
	)
	ftrg << RawTrigger(
		actions=[
			SetMemory(0x6509B0, SetTo, 0), # Set CP
			Action(0, 0, 0, 0, 0, 0, 0, 4, 0, 4),
		]
	)
	f_setcurpl2cpcache()

def onPluginStart(): 
	if EUDIfNot()((Is64BitWireframe())):
		# initialize EWait offsets first
		for key, value in Rewrite.items():
			if not value[-1]: # if rewrite before color setting is needed
				continue
			for addr, size in zip(value[0], value[1]):
				cp = (addr - Address_WAIT) // 4
				for i in range(size):
					SetEWait(cp + i, 0)
	EUDEndIf()

def beforeTriggerExec():
	if EActused > 0: # EUD Actions are used. Currently EUD actions are not supported so this part will be ignored.
		assert False, "EUD Actions are not supported in this version of SCR Colors."

	for conds, labels in cond_label_pairs:
		if EUDExecuteOnce()([interpret_condition(cond) for cond in conds] + [Is64BitWireframe()]):
			for label in labels:
				if label == 'recover':
					# Perform recovery actions
					for shkey, val in R.items():
						for addr, size in zip(Recover[shkey][0], Recover[shkey][1]):
							cp = (addr - Address_WAIT) // 4
							for i in range(size):
								SetEWait(cp + i, 0)
							
						for epd, v in val.items():
							cp = (Addr[shkey] - Address_WAIT) // 4 + epd
							SetEWait(cp, v)
				else:
					assert label in sectors, f"Invalid label {label}."
					shkey = sectors[label]
					for epd, val in D[shkey].items():
						cp = (Addr[shkey] - Address_WAIT) // 4 + epd
						if isinstance(val, int):
							SetEWait(cp, val)
						elif len(val) == 2:
							SetEWait(cp, get_variable_value(val[0]))
						else:
							SetEWait(cp, get_variable_value(val[0]) * val[1] + val[2])
		EUDEndExecuteOnce()

	return 
